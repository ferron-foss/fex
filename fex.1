.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FEX 1"
.TH FEX 1 "2012-03-13" "" ""
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
fex \- simple and powerful field extraction
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBfex\fR \fIselector ...\fR
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
fex helps you split things by field. Common tasks you might do with awk or cut
are much simpler in fex, and there are things in fex you can't do nearly as easily
in awk or cut.
.SH "SELECTOR SYNTAX"
.IX Header "SELECTOR SYNTAX"
The selector syntax looks like this:
.PP
.Vb 1
\&  <delimiter><selection>...
.Ve
.PP
The delimiter is a single character that is used to split the input string.
.PP
The first delimiter is implied as space ' '. You can specify multiple fields
with curly braces and numbers split by commas. Also valid in curly braces {}
are number ranges. Number ranges are similar to python array slices, split by
colon.
.PP
The selection is one of the following and is used to choose fields split by the
delimiter.
.IP "a single number" 4
.IX Item "a single number"
A single number will select that numbered field. Like awk, field start at 1.
.Sp
Example selecting third field:
.Sp
.Vb 2
\&  % echo "a b c d e" | fex \*(Aq3\*(Aq
\&  a b c d
.Ve
.Sp
Example selecting the second field delimited by slash:
.Sp
.Vb 2
\&  % echo "/home/hello/world" | fex \*(Aq/2\*(Aq
\&  hello
.Ve
.IP "{N:M}" 4
.IX Item "{N:M}"
This is a range selection. The syntax for ranges is, in curly braces, N:M,
which chooses the fields in range N to M, inclusive.
.Sp
Example selecting first through fourth fields:
.Sp
.Vb 2
\&  % echo "a b c d e" | fex \*(Aq{1:4}\*(Aq
\&  a b c d
.Ve
.IP "{N,M,...}" 4
.IX Item "{N,M,...}"
The syntax for multiple selections is numbers within curly braces.
.Sp
Example selecting first and fifth fields:
.Sp
.Vb 2
\&  % echo "a b c d e" | fex \*(Aq{1,5}\*(Aq
\&  a e
.Ve
.IP "{range,field,field,range,field}" 4
.IX Item "{range,field,field,range,field}"
Combining the above, you can actually select ranges and individual fields using
the {...} syntax by delimiting each selection by comma.
.Sp
Example selecting fields 1 to 3, and 5: {1:3,5}
.Sp
.Vb 2
\&  % echo "a b c d e" | fex \*(Aq{1:3,5}\*(Aq
\&  a b c e
.Ve
.IP "{?range,field,...}" 4
.IX Item "{?range,field,...}"
The {?...} notation turns on 'non greedy' field separation. The differences here
can be shown best by example, first:
.Sp
.Vb 4
\&  % echo "1...2.3.4" | fex \*(Aq.{1:3}\*(Aq
\&  1.2.3
\&  % echo "1...2.3.4" | fex \*(Aq.{?1:3}\*(Aq
\&  1..
.Ve
.Sp
In the first example, fex uses '.' as delimiter and ignores empty fields. In the 
second example (non greedy), it does not ignore those empty fields.
.IP "/regexp/" 4
.IX Item "/regexp/"
The /regexp/ selection will choose only fields that match the given pattern.
.Sp
Example, pulling out words with 'addr:' in it from 'ifconfig' output:
.Sp
.Vb 3
\&  % ifconfig | fex \*(Aq /addr:[0\-9]/\*(Aq    
\&  addr:127.0.0.1
\&  addr:192.168.0.28
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.IP "Show the \s-1MTU\s0 for a given interface" 4
.IX Item "Show the MTU for a given interface"
The 'mtu' in ifconfig output looks like 'mtu:1500'. So have fex split by space,
then grab fields matching /mtu:/, split by colon, and choose the last field.
.Sp
.Vb 2
\&  % ifconfig wlan0 | fex \*(Aq /mtu:/:\-1\*(Aq
\&  1500
.Ve
.IP "Parse apache logs" 4
.IX Item "Parse apache logs"
Pull the \s-1IP\s0 address (first field by space) and the path requested (2nd field in
\&\*(L"\s-1GET\s0 <path> ...\*(R")
.Sp
.Vb 4
\&    % fex 1 \*(Aq"2 2\*(Aq < /b/logs/access
\&    65.57.245.11 /
\&    65.57.245.11 /icons/blank.gif
\&    65.57.245.11 /icons/folder.gif
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIawk\fR\|(1), \fIcut\fR\|(1),
.PP
Project site: <http://www.semicomplete.com/projects/fex>
.PP
Source Code: <https://github.com/jordansissel/fex>
.SH "CONTACT"
.IX Header "CONTACT"
Please send questions to jls@semicomplete.com
.PP
File bugs and feature requests at the following \s-1URL:\s0
.PP
<https://github.com/jordansissel/fex/issues>
.PP
Alternately, if you prefer email, feel free to file bugs by email.  Whatever
works for you :)
.PP
Patches, ideas, and other contributions by many, nice folks. See the \s-1CHANGELIST\s0
file for who provided what.
.SH "AUTHOR"
.IX Header "AUTHOR"
fex was written by Jordan Sissel.
